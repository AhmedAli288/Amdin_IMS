#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 6.0.1
#  in conjunction with Tcl version 8.6
#    Feb 23, 2021 05:39:36 PM PKT  platform: Windows NT

import platform
import sys
import sqlite3
import tkinter.messagebox as messagebox

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

import return_support
import invoice


r_checkPoint = True


def vp_start_gui():
    '''Starting point when module is the main routine.'''
    global r_checkPoint

    r_checkPoint = False

    global val, w, root
    root = tk.Tk()
    root.protocol('WM_DELETE_WINDOW', destroy_Toplevel1)
    top = Toplevel1(root)
    return_support.init(root, top)
    root.mainloop()


w = None


def create_Toplevel1(rt, *args, **kwargs):
    '''Starting point when module is imported by another module.
       Correct form of call: 'create_Toplevel1(root, *args, **kwargs)' .'''
    global w, w_win, root
    #rt = root
    root = rt
    w = tk.Toplevel(root)
    top = Toplevel1(w)
    return_support.init(w, top, *args, **kwargs)
    return (w, top)


def destroy_Toplevel1():
    global w, r_checkPoint
    r_checkPoint = True
    root.destroy()
    w = None


class Toplevel1:
    def __init__(self, top=None):
        '''This class configures and populates the toplevel window.
           top is the toplevel containing window.'''
        _bgcolor = '#d9d9d9'  # X11 color: 'gray85'
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = '#d9d9d9'  # X11 color: 'gray85'
        _ana1color = '#d9d9d9'  # X11 color: 'gray85'
        _ana2color = '#ececec'  # Closest X11 color: 'gray92'
        self.style = ttk.Style()
        if sys.platform == "win32":
            self.style.theme_use('winnative')
        self.style.configure('.', background=_bgcolor)
        self.style.configure('.', foreground=_fgcolor)
        self.style.configure('.', font="TkDefaultFont")
        self.style.map('.', background=[
                       ('selected', _compcolor), ('active', _ana2color)])

        top.geometry("647x450+247+90")
        top.minsize(120, 1)
        top.maxsize(1370, 749)
        top.resizable(1,  1)
        top.title("Return")
        top.configure(background="#d9d9d9")

        self.style.configure('Treeview',  font="TkDefaultFont")
        self.r_table = ScrolledTreeView(
            top, columns="Col1 Col2 Col3 Col4 Col5")
        self.r_table.place(
            relx=0.021, rely=0.39, relheight=0.482, relwidth=0.82)

        # build_treeview_support starting.
        self.r_table.heading("#0", text="I.D", anchor="center")
        self.r_table.column(
            "#0", width="10", minwidth="20", stretch="1", anchor="w")

        self.r_table.heading("Col1", text="Item Name", anchor="center")
        self.r_table.column(
            "Col1", width="95", minwidth="20", stretch="1", anchor="w")

        self.r_table.heading("Col2", text="Qty", anchor="center")
        self.r_table.column(
            "Col2", width="65", minwidth="10", stretch="1", anchor="w")

        self.r_table.heading(
            "Col3", text="Discount(%)", anchor="center")
        self.r_table.column(
            "Col3", width="65", minwidth="20", stretch="1", anchor="w")

        self.r_table.heading("Col4", text="Price (Rs.)", anchor="center")
        self.r_table.column(
            "Col4", width="65", minwidth="20", stretch="1", anchor="w")

        self.r_table.heading("Col5", text="Total (Rs.)", anchor="center")
        self.r_table.column(
            "Col5", width="65", minwidth="20", stretch="1", anchor="w")

        self.r_table.bind("<Double-1>", self.r_selecting)

        self.menubar = tk.Menu(top, font="TkMenuFont",
                               bg=_bgcolor, fg=_fgcolor)
        top.configure(menu=self.menubar)

        self.TLabel1 = ttk.Label(top, text='''Bill ID''', background="#d9d9d9")
        self.TLabel1.place(relx=0.078, rely=0.035, height=30, width=34)

        self.bill_id_box = tk.Entry(top, background="white")
        self.bill_id_box.place(relx=0.155, rely=0.03,
                               height=30, relwidth=0.2)
        self.bill_id_box.focus_set()

        # Discount box part
        self.Label5 = tk.Label(
            top, text='''Discount(%)''', background="#d9d9d9")
        self.Label5.place(relx=0.032, rely=0.256, height=30, width=90)

        self.prod_disc_spin = tk.IntVar()
        self.r_disc_box = tk.Spinbox(
            top, from_=0, to=10000, background="white", textvariable=self.prod_disc_spin)
        self.r_disc_box.place(relx=0.155, rely=0.256, height=30, relwidth=0.2)
        self.r_disc_box.bind('<Tab>', self.r_update_show)
        self.prod_disc_spin.set("")

        # Qty box part
        self.Label3 = tk.Label(top, text='''Quantity''', background="#d9d9d9")
        self.Label3.place(relx=0.52, rely=0.256, height=30, width=50)

        self.prod_qty_spin = tk.IntVar()
        self.qty_box = tk.Spinbox(
            top, from_=1, to=10000, background="white", textvariable=self.prod_qty_spin)
        self.qty_box.place(relx=0.639, rely=0.256, height=30, relwidth=0.2)
        self.prod_qty_spin.set("")

        self.updt_btn = tk.Button(
            top, text='''Update''', background="#d9d9d9", command=self.r_update)
        self.updt_btn.place(relx=0.85, rely=0.39, height=50, width=90)
        self.updt_btn.bind('<Button-1>', lambda event,
                           entryField=self.r_disc_box: self.r_update_test(event, entryField))

        self.dlt_btn = tk.Button(
            top, text='''Delete''', background="#d9d9d9", command=self.r_deleting)
        self.dlt_btn.place(relx=0.85, rely=0.56, height=50, width=90)

        self.prnt_btn = tk.Button(top, text='''Print''', background="#d9d9d9")
        self.prnt_btn.place(relx=0.85, rely=0.73, height=50, width=90)

        # Grand Total box part
        self.Label1 = tk.Label(
            top, text='''Grand total''', background="#d9d9d9")
        self.Label1.place(relx=0.46, rely=0.9, height=30, width=73)

        self.r_grand = tk.IntVar()
        self.grand_box = tk.Label(
            top, background="white", textvariable=self.r_grand)
        self.grand_box.place(relx=0.64, rely=0.9, height=30, relwidth=0.2)
        self.r_grand.set("")

        # Product name box part
        self.Label2 = tk.Label(top, text='''Product''', background="#d9d9d9")
        self.Label2.place(relx=0.062, rely=0.156, height=30, width=44)

        self.prod_name = tk.IntVar()
        self.p_name_box = tk.Label(
            top, background="white", textvariable=self.prod_name)
        self.p_name_box.place(
            relx=0.155, rely=0.156, height=30, relwidth=0.2)
        self.prod_name.set("")

        # Search Button
        self.srch_btn = tk.Button(
            top, text='''Search''', background="#d9d9d9")
        self.srch_btn.place(relx=0.38, rely=0.03, height=30, width=90)
        top.bind(
            "<Return>", lambda event, entryField=self.p_name_box: self.searching_return(event, entryField))

        # Price box part
        self.Label4 = tk.Label(
            top, text='''Discounted Price''', background="#d9d9d9")
        self.Label4.place(relx=0.49, rely=0.156, height=30, width=90)

        self.prod_price = tk.IntVar()
        self.price_box = tk.Label(
            top, background="white", textvariable=self.prod_price)
        self.price_box.place(relx=0.639, rely=0.156, height=30, relwidth=0.2)
        self.prod_price.set("")

    def r_selecting(self, event):
        name = self.r_table.item(self.r_table.selection())['values'][0]
        qty = self.r_table.item(self.r_table.selection())['values'][1]
        disc = self.r_table.item(self.r_table.selection())['values'][2]
        price = self.r_table.item(self.r_table.selection())['values'][3]

        self.prod_name.set(name)
        self.prod_qty_spin.set(qty)
        self.prod_disc_spin.set(disc)
        self.prod_price.set(price)

    def r_update_show(self, event):

        name = self.r_table.item(self.r_table.selection())['values'][0]

        print(name)

        conn = sqlite3.connect('ims.db')
        my_cursor = conn.execute(
            "SELECT rowid,* FROM product WHERE name=?", (name,))
        data_row = my_cursor.fetchone()

        prod_price = data_row[3]

        get_add_disc = int(self.r_disc_box.get())

        disc_price = (get_add_disc / 100) * prod_price

        price = prod_price - disc_price

        self.prod_price.set(price)

        my_cursor.close()
        conn.close()

        event.widget.tk_focusNext().focus()

        return('break')

    def r_printing(self, event):

        conn = sqlite3.connect('ims.db')
        c = conn.cursor()

        tree_items = []

        for i in self.r_table.get_children():
            tree_items.append(self.r_table.item(i)['values'])

            item = self.r_table.item(i)['values'][0]
            quty = int(float(self.r_table.item(i)['values'][1]))
            discnt = float(self.r_table.item(i)['values'][2])
            prices = float(self.r_table.item(i)['values'][3])
            total_prices = float(self.r_table.item(i)['values'][4])

        print(tree_items)

        for i, item in enumerate(tree_items):
            item.insert(0, i+1)

        print(tree_items)

        c.close()
        conn.close()

        grand_total = self.grand_total

        bill_ids = self.bill_id_box.get()

        invoice.print_invoice(bill_ids, tree_items, grand_total)

        # Clearing boxes
        self.qty_spin.set('1')
        self.p_cbox.delete(0, 'end')
        self.p_str.set("")
        self.disc_p_str.set("")
        self.add_disc_spin.set('0')
        self.sub.set("")
        self.balance.set("")
        self.grand.set("")
        self.pay_box.set("")

        # tree view remove all
        for row in self.r_table.get_children():
            self.p_table.delete(row)

    def r_update_test(self, event, entryField):
        self.r_update()

        root.after(1, lambda: entryField.focus_set())

        return("break")

    def r_update(self):

        selected = self.r_table.focus()

        name = str(self.r_table.item(self.r_table.selection())['values'][0])

        stock = int(float(self.r_table.item(
            self.r_table.selection())['values'][1]))

        bill_ids = int(self.bill_id_box.get())
        print(bill_ids, type(bill_ids))

        conn = sqlite3.connect('ims.db')

        my_cursor = conn.execute(
            "SELECT rowid,* FROM product WHERE name=?", (name,))
        data_row = my_cursor.fetchone()

        st = data_row[2]

        prod_price = data_row[3]

        disc_prcnt = float(self.r_disc_box.get())

        disc_price = (disc_prcnt / 100) * prod_price

        d_prod_price = prod_price - disc_price

        print("discounted price: ", d_prod_price, type(d_prod_price))

        prod_qty = int(self.qty_box.get())

        t_price = d_prod_price * prod_qty

        print("total price: ", t_price, type(t_price))

        # stmt = """UPDATE items SET qty = :qty, discount = :discount, price = :price, total_price = :total_price WHERE bill_id = :bill_id and item_name = :item_name"""

        my_cursor = conn.execute("""UPDATE items SET qty = :qty, discount = :discount, price = :price, total_price = :total_price WHERE bill_id = :bill_id and item_name = :item_name""", dict(
            qty=prod_qty, discount=disc_prcnt, price=d_prod_price, total_price=t_price, bill_id=bill_ids, item_name=name))

        conn.commit()

        if stock > prod_qty:
            stk = stock - prod_qty
            qty = st + stk
            my_cursor = conn.execute(
                "UPDATE product SET stock = ? WHERE name = ?", (qty, name))
            conn.commit()

        elif stock < prod_qty:
            stk = prod_qty - stock
            qty = st - stk

            if qty < 0:
                messagebox.showerror("Warning", "Out of Stock!")
            else:
                my_cursor = conn.execute(
                    "UPDATE product SET stock = ? WHERE name = ?", (qty, name))
                conn.commit()

        elif stock == prod_qty:
            pass

        self.r_table.item(selected, text="", values=(
            name, prod_qty, disc_prcnt, d_prod_price, t_price))

        my_cursor.close()
        conn.close()

        # For Grand Total calculation
        self.g_total = 0
        for i in self.r_table.get_children():
            total_prices = float(self.r_table.item(i)['values'][4])
            self.g_total += total_prices
            print(self.g_total)

        self.r_grand.set(self.g_total)

        # Clearing Boxes
        self.prod_name.set("")
        self.prod_qty_spin.set("")
        self.prod_disc_spin.set("")
        self.prod_price.set("")

    def searching_return(self, event, entryField):

        self.searching()

        root.after(1, lambda: entryField.focus_set())

        return("break")

    def searching(self):
        # tree view remove all
        for row in self.r_table.get_children():
            self.r_table.delete(row)

        conn = sqlite3.connect('ims.db')

        bill_id = int(self.bill_id_box.get())

        if self.bill_id_box.get() == "":
            messagebox.showerror("Warning", "Enter Bill ID!")

        else:
            my_cursor = conn.execute(
                "SELECT * FROM items WHERE bill_id=?", (bill_id,))
            items = my_cursor.fetchall()

            count = 1
            self.g_total = 0
            for item in items:
                self.g_total += item[4]
                self.r_table.insert('', 'end', text=count,
                                    values=(item[0], item[1], item[2], item[3], item[4])),
                count += 1
                print(self.g_total)

            self.r_grand.set(self.g_total)

            my_cursor.close()
            conn.close()

    def r_deleting(self):
        bill_ids = int(self.bill_id_box.get())

        # selected item
        items = self.r_table.selection()

        # getting name of a product in tree view
        name = self.r_table.item(self.r_table.selection())['values'][0]

        # getting qty of a product in tree view
        qty = self.r_table.item(self.r_table.selection())['values'][1]
        qty = float(qty)

        # getting total price in tree view
        prod_total = self.r_table.item(self.r_table.selection())['values'][4]
        prod_total = float(prod_total)

        self.g_total = self.g_total - prod_total
        self.r_grand.set(self.g_total)

        conn = sqlite3.connect('ims.db')

        # Updating in product table
        my_cursor = conn.execute(
            "SELECT rowid,* FROM product WHERE name=?", (name,))
        data_row = my_cursor.fetchone()

        print(data_row[2])

        st = data_row[2] + qty

        my_cursor = conn.execute(
            "UPDATE product SET stock = ? WHERE name = ?", (st, name))
        conn.commit()

        # Deleting from items table
        my_cursor = conn.execute("DELETE FROM items WHERE bill_id = :bill_ids and item_name= :item",
                                 dict(bill_ids=bill_ids, item=name))
        conn.commit()

        # print(data_row[1])
        print("Added Stock: ", st)

        my_cursor.close()
        conn.close()

        self.r_table.delete(items)

# The following code is added to facilitate the Scrolled widgets you specified.


class AutoScroll(object):
    '''Configure the scrollbars for a widget.'''

    def __init__(self, master):
        #  Rozen. Added the try-except clauses so that this class
        #  could be used for scrolled entry widget for which vertical
        #  scrolling is not supported. 5/7/14.
        try:
            vsb = ttk.Scrollbar(master, orient='vertical', command=self.yview)
        except:
            pass
        hsb = ttk.Scrollbar(master, orient='horizontal', command=self.xview)
        try:
            self.configure(yscrollcommand=self._autoscroll(vsb))
        except:
            pass
        self.configure(xscrollcommand=self._autoscroll(hsb))
        self.grid(column=0, row=0, sticky='nsew')
        try:
            vsb.grid(column=1, row=0, sticky='ns')
        except:
            pass
        hsb.grid(column=0, row=1, sticky='ew')
        master.grid_columnconfigure(0, weight=1)
        master.grid_rowconfigure(0, weight=1)
        # Copy geometry methods of master  (taken from ScrolledText.py)
        if py3:
            methods = tk.Pack.__dict__.keys() | tk.Grid.__dict__.keys() \
                | tk.Place.__dict__.keys()
        else:
            methods = tk.Pack.__dict__.keys() + tk.Grid.__dict__.keys() \
                + tk.Place.__dict__.keys()
        for meth in methods:
            if meth[0] != '_' and meth not in ('config', 'configure'):
                setattr(self, meth, getattr(master, meth))

    @staticmethod
    def _autoscroll(sbar):
        '''Hide and show scrollbar as needed.'''
        def wrapped(first, last):
            first, last = float(first), float(last)
            if first <= 0 and last >= 1:
                sbar.grid_remove()
            else:
                sbar.grid()
            sbar.set(first, last)
        return wrapped

    def __str__(self):
        return str(self.master)


def _create_container(func):
    '''Creates a ttk Frame with a given master, and use this new frame to
    place the scrollbars and the widget.'''
    def wrapped(cls, master, **kw):
        container = ttk.Frame(master)
        container.bind('<Enter>', lambda e: _bound_to_mousewheel(e, container))
        container.bind(
            '<Leave>', lambda e: _unbound_to_mousewheel(e, container))
        return func(cls, container, **kw)
    return wrapped


class ScrolledTreeView(AutoScroll, ttk.Treeview):
    '''A standard ttk Treeview widget with scrollbars that will
    automatically show/hide as needed.'''
    @_create_container
    def __init__(self, master, **kw):
        ttk.Treeview.__init__(self, master, **kw)
        AutoScroll.__init__(self, master)


def _bound_to_mousewheel(event, widget):
    child = widget.winfo_children()[0]
    if platform.system() == 'Windows' or platform.system() == 'Darwin':
        child.bind_all('<MouseWheel>', lambda e: _on_mousewheel(e, child))
        child.bind_all('<Shift-MouseWheel>',
                       lambda e: _on_shiftmouse(e, child))
    else:
        child.bind_all('<Button-4>', lambda e: _on_mousewheel(e, child))
        child.bind_all('<Button-5>', lambda e: _on_mousewheel(e, child))
        child.bind_all('<Shift-Button-4>', lambda e: _on_shiftmouse(e, child))
        child.bind_all('<Shift-Button-5>', lambda e: _on_shiftmouse(e, child))


def _unbound_to_mousewheel(event, widget):
    if platform.system() == 'Windows' or platform.system() == 'Darwin':
        widget.unbind_all('<MouseWheel>')
        widget.unbind_all('<Shift-MouseWheel>')
    else:
        widget.unbind_all('<Button-4>')
        widget.unbind_all('<Button-5>')
        widget.unbind_all('<Shift-Button-4>')
        widget.unbind_all('<Shift-Button-5>')


def _on_mousewheel(event, widget):
    if platform.system() == 'Windows':
        widget.yview_scroll(-1*int(event.delta/120), 'units')
    elif platform.system() == 'Darwin':
        widget.yview_scroll(-1*int(event.delta), 'units')
    else:
        if event.num == 4:
            widget.yview_scroll(-1, 'units')
        elif event.num == 5:
            widget.yview_scroll(1, 'units')


def _on_shiftmouse(event, widget):
    if platform.system() == 'Windows':
        widget.xview_scroll(-1*int(event.delta/120), 'units')
    elif platform.system() == 'Darwin':
        widget.xview_scroll(-1*int(event.delta), 'units')
    else:
        if event.num == 4:
            widget.xview_scroll(-1, 'units')
        elif event.num == 5:
            widget.xview_scroll(1, 'units')


if __name__ == '__main__':
    vp_start_gui()
